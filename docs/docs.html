<!DOCTYPE html>
<html>
	<head>
		<!--<meta name="robots" content="noindex, nofollow">-->
		<meta name="robots" content="index, follow">
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<meta name="description" content = "Documentation for cipherJS">
		<meta name="keywords" content = "cipherjs, javascript cipher js, javascript encryption, javascript cryptography, ecc, ecdsa, asynchronous javascript encryption, asymmetric javascript encryption, pgp javascript, openpgp javascript, aes, twofish, serpent, rijndael, asynchronous ecc, ecc rsa javascript, sha javascript, sha1, sha256, sha512, sha javascript, hash, encryption javascript, javascript crypto library, js crypto">
		<link rel="stylesheet" type="text/css" href="./css/default.css" title="default">
		<title>cipherJS documentation</title>
	</head>
	<body>
		<!--<div class="main backlink">-->
			<p class="main backlink"><a class="main backlink" href="#docs_top">Back</a></p>
		<!--</div>-->
		<div class="main" id="docs_top">
			<ul class="main outer">
				<li class="main outer"><a href="#cipherjs">cipherJS</a></li>
				<li class="main outer">
					<ul class="main inner">
						<li class="main inner"><a href="#about">About</a></li>
						<li class="main inner"><a href="#credits">Credits</a></li>
						<li class="main inner"><a href="#warning">Warning</a></li>
					</ul>
				</li>
				<li class="main outer"><a href="#api">API Docs</a></li>
				<li class="main outer">
					<ul class="main inner">
						<li class="main inner"><a href="#init">cipherJS.init</a></li>
						<li class="main inner"><a href="#add">Additional functions</a></li>
						<li class="main inner"><a href="#random">cipherJS.random</a></li>
						<li class="main inner"><a href="#enc">cipherJS.enc</a></li>
						<li class="main inner"><a href="#mask">cipherJS.mask</a></li>
						<li class="main inner"><a href="#hash">cipherJS.hash</a></li>
						<li class="main inner"><a href="#sym">cipherJS.sym</a></li>
						<li class="main inner"><a href="#asymsimple">cipherJS.asym.simple</a></li>
						<li class="main inner"><a href="#asym">cipherJS.asym</a></li>
					</ul>
				</li>
				<li class="main outer"><a href="#async">Asynchronous Javascript</a></li>
				<li class="main outer">
					<ul class="main inner">
						<li class="main inner"><a href="#async_general">Asynchronous functions in Javascript</a></li>
						<li class="main inner"><a href="#async_cipherjs">Asynchronous functions in cipherJS</a></li>
					</ul>
				</li>
				<li class="main outer"><a href="#dangers">Dangers of (Javascript) cryptography</a></li>
				<li class="main outer">
					<ul class="main inner">
						<li class="main inner"><a href="#transmit">Transmitting scripts to the client</a></li>
						<li class="main inner"><a href="#keystorage">Storing keys on a server</a></li>
						<li class="main inner"><a href="#transparency">Trust in your application</a></li>
						<li class="main inner"><a href="#mim">The man in the middle attack</a></li>
					</ul>
				</li>
			</ul>
		</div>
		<h1 class="main" id="cipherjs">cipherJS</h1>
		<div class="main" id="about">
			<!--<h2 class="main">About cipherJS</h2>-->
			<p class="main">
				cipherJS is a client side Javascript encryption library. It provides
				symmetric and asymmetric encryption as well as hashing, encoding and
				random numbers and strings.
			</p>
			<p class="main">
			To use cipherJS, include the following lines in a document's head:
				<br>
				<code class="main">
					&lt;script src="/path/to/sjcl.min.js" type="text/javascript"&gt;&lt;/script&gt;
					<br>
					&lt;script src="/path/to/titaniumcore.cipher.min.js" type="text/javascript"&gt;&lt;/script&gt;
					<br>
					&lt;script src="/path/to/cipherjs.min.js" type="text/javascript"&gt;&lt;/script&gt;
				</code>
			</p>
			<p class="main">
				cipherJS is made for web applications, add-ons, any kind of client side
				HTML5 app, but not for client-server-encryption. 
				It is not "cheap SSL".
			</p>
			<p class="main">
				cipherJS tries to make encryption as easy to access and simple to use as
				possible. Almost all input and output is text-based. 
				Asynchronous execution of longer running functions avoids
				slowness and hitting browser limits.<br>
				Still, always be more careful with cryptography than with other parts
				of an application. Most code will tell you soon when there is a bug. 
				Cryptography may just "work" until cracked. Read the docs, think what an
				attacker would do to break your security: Most flaws found in recent
				HTML5 crypto apps would've been avoidable.
			</p>
		</div>
		<div class="main" id="credits">
			<h2 class="main">Credits</h2>
			<p class="main">
				cipherJS did <strong class="main">not</strong> implement all the algorithms
				once more. It forks <a class="main" href="https://github.com/bitwiseshiftleft/sjcl" 
				target="_blank">SJCL</a> and uses <a class="main" href="http://ats.oka.nu/titaniumcore/js/crypto/readme.txt" target="_blank">
				titaniumcore</a>.
			</p>
			<p class="main">
				"Full" SJCL is included in sjcl.min.js, while titaniumcore.cipher.min.js 
				only contains the symmetric ciphers (Rijndael, Twofish, Serpent). <br>
				cipherJS' SJCL fork changes SJCL's ECC to work asynchronously. Synchronous 
				functions are still present, but not used in cipherJS. The 521 bit curve was
				added.
				<br>
				The SJCL version currently used is the version present on Github in August 2013.
				It does not yet include any changes made in September and after.
			</p>
			<p class="main">
				Think of cipherJS as a high level wrapper for SJCL and titaniumcore.
			</p>
		</div>
		<div class="main" id="warning">
			<h2 class="main">Warning</h2>
			<p class="main">
				cipherJS may make cryptography in Javascript easier, but it still 
				is a beta library: <strong class="main">Do not use it in 
				extremely dangerous situations, rely on more well tested 
				applications</strong>.
			</p>
			<p class="main">
				Be extremely careful with cryptography. Read all the
				docs, think what an attacker would do, do not promise 100% security.
				Be honest when describing your application.
			</p>
			<p class="main">
				Please note that cipherJS uses ECC (NIST curves) for asymmetric encryption
				and signing. There has been a lot of controversy and discussion about
				whether ECC, especially NIST-ECC, can be considered secure or may
				contain a backdoor (yet, no backdoor has been found).<br> Compared to 
				rather young or unstable implementations of Curve25519 (and cipherJS would not
				rely on ECDH alone) and RSA keys which would either be too small or too slow (sorry),
				NIST ECC still appears to be the best choice at the moment. More way of asymmetric
				encryption may follow.
			</p>
		</div>
		<h1 class="main" id="api">API Docs</h1>
		<div class="main" id="init">
			<h2 class="main">cipherJS.init</h2>
			<p class="main">
				cipherJS must be initialized before usage, which means 
				collecting a lot of random values.<br>
				If <code class="main">window.crypto.getRandomValues</code> is found, this
				is very fast, not even noticed by a user. <br>
				If <code class="main">window.crypto.getRandomValues</code> is not present, 
				random values have to be collected from random mouse- or touchmoves. 
				(<code class="main">Math.random</code> usually is not cryptographically random, so
				can't be used here). 
			</p>
			<h2 class="main">cipherJS.init.init</h2>
			<strong class="main"><code class="main">cipherJS.init.init(entropyId, doneDOMObj, entropyInfoId, doneInfoDOMObj)</code></strong>
			<p class="main">
				cipherJS provides the <code class="main">cipherJS.init</code> method to 
				collect random values and update the page when cipherJS is initialised.
				<br>
				Please check the examples to see how to use <code class="main">cipherJS.init</code>
				correctly.
			</p>
<pre class="main">
/**
* Initiate SJCL's PRNG by collecting random values from mouse/ touchpad,
* window.crypto.getRandomValues and Math.random (yes, it is not secure
* in all browsers - that's what getRandomValues and the mouse thing are for).
* events.
* ----------------------------------------------------------------------
* @param   {String}    entropyId        ID of the element where the progress
*                                       of collection will be shown and where
*                                       the doneDOMObj will be displayed when 
*                                       enough values have been collected.
* @param   {DOMObject} doneDOMObj       DOM object to display when values
*                                       have been collected.
* @param   {String}    entropyInfoId    (Optional) ID of the element where you
*                                       provide some info like "Move your 
*                                       mouse or use your fingers on your 
*                                       touchpad/ touchscreen as randomly 
*                                       as possible until you see a 100% and the
*                                       proceed button below".
*                                       This message will disappear and @doneInfoDOMObj
*                                       will be shown when entropy is collected (i.e.
*                                       if window.crypto.getRandomValues is available, so
*                                       users won't see this message at all, or when 
*                                       they've moved long enough for entropy to be 
*                                       collected).
* @param   {DOMObject} doneInfoDOMObj   (Optional) Can be something empty or whatever you wish to
*                                       additionally tell the user (such as "Click on the
*                                       proceed button below to go to our page") after
*                                       entropy has been collected.
* */
</pre>
		</div>
		<div class="main" id="add">
			<h2 class="main">Additional functions</h2>
			<p class="main">
				cipherJS extends <code class="main">String.prototype</code>
				to provide additional string related functions.
			</p>
			<p class="main">
				If <code class="main">window.crypto.getRandomValues</code> is available,
				<code class="main">Math.random</code> is overwritten using <code class="main">getRandomValues</code>
				to provide a cryptographically random <code class="main">Math.random</code>. 
				Please don't rely on this as <code class="main">getRandomValues</code> is not
				available in all browsers.
			</p>
			<h3 class="main">String.prototype.replaceAll</h3>
			<strong class="main"><code class="main">String.prototype.replaceAll(find, replace)</code></strong>
			<p class="main"></p>
<pre class="main">
/**
* Replaces all occurences of @find with @replace.
* ---------------------------------------------------------------------
* @param   {String}   find      String to replace
* @param   {String}   replace   String to replace @find with
* @return  {String}
* */
</pre>
			<h3 class="main">String.prototype.startsWith</h3>
			<strong class="main"><code class="main">String.prototype.startsWith(str)</code></strong>
			<p class="main">
			</p>
<pre class="main">
/**
* Checks if a string starts with another.
* ---------------------------------------------------------------------
* @param  {String} str
* @return {String}
* */
</pre>
		<h3 class="main">String.prototype.trim</h3>
		<strong class="main"><code class="main">String.prototype.trim()</code></strong>
		<p class="main">
		</p>
<pre class="main">
/**
* Trim a given String, i.e. remove whitespaces at the beginning and end.
* ---------------------------------------------------------------------
* @return {String}
* */
</pre>
		<h3 class="main">String.prototype.allTrim</h3>
		<strong class="main"><code class="main">String.prototype.allTrim()</code></strong>
		<p class="main">
		</p>
<pre class="main">
/**
* Trim and remove multiple whitespaces from a string.
* ---------------------------------------------------------------------
* @return {String}
* */
</pre>
		<h3 class="main">String.prototype.removeWhitespace</h3>
		<strong class="main"><code class="main">String.prototype.removeWhitespace()</code></strong>
		<p class="main">
		</p>
<pre class="main">
/**
* Remove whitespace characters from string.
* ---------------------------------------------------------------------
* @return {String}
* */
</pre>
		<h3 class="main">String.prototype.removeLinebreaks</h3>
		<strong class="main"><code class="main">String.prototype.removeLinebreaks()</code></strong>
		<p class="main">
		</p>
<pre class="main">
/**
* Remove linebreak characters from string.
* ---------------------------------------------------------------------
* @return {String}
* */
</pre>
		<h3 class="main">String.prototype.removeWhitespaceAndLinebreaks</h3>
		<strong class="main"><code class="main">String.prototype.removeWhitespaceAndLinebreaks()</code></strong>
		<p class="main">
		</p>
<pre class="main">
/**
* Remove whitespace and linebreak characters from string.
* ---------------------------------------------------------------------
* @return {String}
* */
</pre>
		<h3 class="main">String.prototype.between</h3>
		<strong class="main"><code class="main">String.prototype.between(start, end)</code></strong>
		<p class="main">
		</p>
<pre class="main">
/**
* Returns a string between two strings. Checks for the first 
* occurence of @param start an the next occurence of @param end
* after this.
* ---------------------------------------------------------------------
* @param   {String} start
* @param   {String} end
* @return  {String}
* */
</pre>
		<h3 class="main">String.prototype.chunk</h3>
		<strong class="main"><code class="main">String.prototype.chunk(len)</code></strong>
		<p class="main">
		</p>
<pre class="main">
/**
* Chunk a string in pieces of the specified length.
* ---------------------------------------------------------------------
* @param  {Integer}        length   (Max.) length of the chunks 
* @return {Array&lt;String&gt;}
* */
</pre>
		</div>
		<div class="main" id="random">
			<h2 class="main">cipherJS.random</h2>
			<p class="main">
				<code class="main">cipherJS.random</code> provides convenient
				functions for cryptographically random numbers and strings
				(<code class="main">Math.random</code> usually is not cryptographically
				random).
			</p>
			<h3 class="main">cipherJS.random.randomNumber</h3>
			<strong class="main"><code class="main">cipherJS.random.randomNumber()</code></strong>
			<p class="main">
			</p>
<pre class="main">
/**
* Returns a usually large random integer.
* ---------------------------------------------------------------------
* @return {Integer}
* */
</pre>
			<h3 class="main">cipherJS.random.mathRandom</h3>
			<strong class="main"><code class="main">cipherJS.random.mathRandom()</code></strong>
			<p class="main">
			</p>
<pre class="main">
/**
* Returns random values in the way Math.random does, just 
* cryptographically secure.
* ---------------------------------------------------------------------
* @return {Float}
* */
</pre>
			<h3 class="main">cipherJS.random.randomFloat</h3>
			<strong class="main"><code class="main">cipherJS.random.randomFloat(min, max)</code></strong>
			<p class="main">
			</p>
<pre class="main">
/**
* Returns a random float between min and max.
* ---------------------------------------------------------------------
* @return {Float}
* */
</pre>
			<h3 class="main">cipherJS.random.randomInteger</h3>
			<strong class="main"><code class="main">cipherJS.random.randomInteger(min, max)</code></strong>
			<p class="main">
			</p>
<pre class="main">
/**
* Return an integer in a specific range. (Including min, excluding max,
* so min=1 and max=4 will output possible results of 1, 2 or 3).
* ---------------------------------------------------------------------
* @return {Integer}
* */
</pre>
			<h3 class="main">cipherJS.random.randomString</h3>
			<strong class="main"><code class="main">cipherJS.random.randomString(len, enc)</code></strong>
			<p class="main">
			</p>
<pre class="main">
/**
* Create a long random alphanumeric string. Good for hard to crack,
* easy to use passphrases.
* ---------------------------------------------------------------------
* @param  {Integer}  len   Length of the random key string (chars)
* @param  {String}   enc   (Optional) can be set to "hex" for a 
*                          hex string.
* @return {String}
* */
</pre>
		</div>
		<div class="main" id="enc">
			<h2 class="main">cipherJS.enc</h2>
			<p class="main">
				cipherJS provides functions for encoding strings in 
				UTF8, Base64 or hexadecimally. It also allows converting
				strings to bits and bitarrays to strings.
			</p>
			<h3 class="main">cipherJS.enc.toHex</h3>
			<strong class="main"><code class="main">cipherJS.enc.toHex(data, enc)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Hex-encodes an Utf8- or Base64-String.
* ---------------------------------------------------------------------
* @param   {String}   data   Utf8- or Base64-String
* @param   {String}   enc    "utf8" or "base64", current encoding 
*                            of @data
* @return  {String}          hex-encoded string
* */
			</pre>
			<h3 class="main">cipherJS.enc.toBase64</h3>
			<strong class="main"><code class="main">cipherJS.enc.toBase64(data, enc)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Base64-encodes a Hex- or Utf8-String.
* ---------------------------------------------------------------------
* @param   {String}   data   Hex- or Utf8-String
* @param   {String}   enc    "hex" or "utf8", current encoding 
*                            of @data
* @return  {String}          base64-encoded string
* */
			</pre>
			<h3 class="main">cipherJS.enc.toUtf8</h3>
			<strong class="main"><code class="main">cipherJS.enc.toUtf8(data, enc)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Utf8-encodes a Hex- or Utf8-String.
* ---------------------------------------------------------------------
* @param   {String}   data   Hex- or Base64-String
* @param   {String}   enc    "hex" or "base64", current encoding 
*                            of @data
* @return  {String}          utf8-encoded string
* */
			</pre>
			<h3 class="main">cipherJS.enc.toBits</h3>
			<strong class="main"><code class="main">cipherJS.enc.toBits(data, enc)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Transforms a string of a given encoding to a bit array.
* ---------------------------------------------------------------------
* @param   {String}   data  Data string to encode
* @param   {String}   enc   Current encoding of data ("utf8", "hex", "base64")
* @return  {Array&lt;Integer&gt;}
* */
			</pre>
			<h3 class="main">cipherJS.enc.fromBits</h3>
			<strong class="main"><code class="main">cipherJS.enc.fromBits(data, enc)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Transforms a bit array to a string of a certain encoding.
* ---------------------------------------------------------------------
* @param   {Array&lt;Integer&gt;}   data   bitArray to transform to a string
* @param   {String}           enc    "utf8", "base64", "hex"
* @return  {String}
* */
			</pre>
		</div>
		<div class="main" id="mask">
			<h2 class="main">cipherJS.mask</h2>
			<p class="main">
				cipherJS' asymmetric encryption and signing functions 
				expect masked cleartext, i.e. cleartext that does not contain
				XML, JSON and - best - few or no special chars.<br>
				Masking functions in cipherJS output masked text that is 
				nothing but alphanumeric and '%' characters. Unmasking
				recreates the actual text.
			</p>
			<p class="main">
				You might find even this kind of masked text "screwed" after 
				sending over the network, as some servers decode URI components 
				automatically.<br>
				There are two solutions to this:
				<br>
				a) Use <code class="main">encodeURIComponent</code> for masked text as well.
				<br>
				b) <code class="main">encodeURIComponent</code>, and replace all '%' by some
				   other rather untroublesome specialchar like '*'.
			</p>
			<h3 class="main">cipherJS.mask.mask</h3>
			<strong class="main"><code class="main">cipherJS.mask.mask(str)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Mask a string so that after masking, it only contains alphanumeric
* characters and %. 
* ---------------------------------------------------------------------
* To mask a string, it is base64-encoded and then encoded using 
* encodeURIComponent. As a result, only alphanumeric and % are present
* in the masked string, which will not give any trouble when transferred
* over the network or passed to asymmetric encryption functions as 
* a cleartext (they are not supposed to take XML or JSON cleartexts,
* and users could any time include text or JSON data in their messages).
* ---------------------------------------------------------------------
* @param   {String}   str   String to mask
* @return  {String}         Masked string
* */
			</pre>
			<h3 class="main">cipherJS.mask.unmask</h3>
			<strong class="main"><code class="main">cipherJS.mask.unmask(str)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Unmask a string that was masked using cipherJS.mask.mask. 
* ---------------------------------------------------------------------
* @str is first decoded using decodeURIComponent, and then the 
* resulting base64 string is utf8-encoded, resulting in the original
* string.
* ---------------------------------------------------------------------
* @param   {String}   str   Masked text
* @return  {String}         Original text, unmasked
* */
			</pre>
		</div>
		<div class="main" id="hash">
			<h2 class="main">cipherJS.hash</h2>
			<p class="main">
				cipherJS provides hashing functions for strings. It 
				has SHA1, SHA256 and SHA512 available. MD5 is not 
				present and will not be.<br>
				SHA1 is deprecated, use it for legacy purposes only.
			</p>
			<h3 class="main">cipherJS.hash.sha1</h3>
			<strong class="main"><code class="main">cipherJS.hash.sha1(data, enc)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* SHA1-hash a given string and receive output in Hex, Base64 or as an
* array.
* ---------------------------------------------------------------------
* @param   {String}   str   String to hash
* @param   {String}   enc   Encoding of the hash, "hex", "base64" or "none".
*                           Output will be a bit array (array of integer)
*                           for "none", and a string for the other 
*                           options.
* @return {String | Array&lt;Integer&gt;}
* */
			</pre>
			<h3 class="main">cipherJS.hash.sha256</h3>
			<strong class="main"><code class="main">cipherJS.hash.sha256(data, enc)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* SHA256-hash a given string and receive output in Hex, Base64 or as an
* array.
* ---------------------------------------------------------------------
* @param   {String}   str   String to hash
* @param   {String}   enc   Encoding of the hash, "hex", "base64" or "none".
*                           Output will be a bit array (array of integer)
*                           for "none", and a string for the other 
*                           options.
* @return {String | Array&lt;Integer&gt;}
* */
			</pre>
			<h3 class="main">cipherJS.hash.sha512</h3>
			<strong class="main"><code class="main">cipherJS.hash.sha512(data, enc)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* SHA512-hash a given string and receive output in Hex, Base64 or as an
* array.
* ---------------------------------------------------------------------
* @param   {String}   str   String to hash
* @param   {String}   enc   Encoding of the hash, "hex", "base64" or "none".
*                           Output will be a bit array (array of integer)
*                           for "none", and a string for the other 
*                           options.
* @return {String | Array&lt;Integer&gt;}
* */
			</pre>
		</div>
		<div class="main" id="sym">
			<h2 class="main">cipherJS.sym</h2>
			<p class="main">
				cipherJS provides functions for symmetric encryption
				of strings.<br>
				Encryption and decryption is pretty straightforward: Pass
				a data string and a password to a function, specify an 
				algorithm if encrypting, and receive the result.
				<br>
				Output always is an UTF8-encoded string
				(some JSON, no rare special characters). 
			</p>
			<p class="main">
				cipherJS supports AES, Rijndael, Twofish,
				Serpent and a combination of AES and Twofish. Default keysize
				is 256 bit.
			</p>
			<h3 class="main">cipherJS.sym.encrypt</h3>
			<strong class="main"><code class="main">cipherJS.sym.encrypt(data, pass, algorithm)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Encrypt @data using @password. Use @algorithm as encryption algorithm.
* ---------------------------------------------------------------------
* @param   {String}   data         Data string to encrypt
* @param   {String}   pass         Password to use for encryption
* @param   {String}   algorithm    Algorithm to use for encryption.
*                                  "aes", "rijndael", "twofish", "serpent",
*                                  "aes-twofish" are possible.
* @return  {String} 
* */
			</pre>
			<h3 class="main">cipherJS.sym.decrypt</h3>
			<strong class="main"><code class="main">cipherJS.sym.decrypt(data, pass)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Decrypt a string that was encrypted using cipherJS.sym.encrypt, 
* recognize encryption algorithm automatically.
* ---------------------------------------------------------------------
* @param   {String}   data   Ciphertext to decrypt
* @param   {String}   pass   Password to use for decryption
* @return  {String}
* */
			</pre>
			<h3 class="main">cipherJS.sym.encryptAsync</h3>
			<strong class="main"><code class="main">cipherJS.sym.encryptAsync(data, pass, algorithm, callback, carrier)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Encrypt @data asynchronously using @pass. This makes sense for very
* long @data strings.
* Usually, symmetric encryption is best done synchronously, as 
* encrypting strings even of a few thousand characters is pretty fast.
* Asynchronous symmetrical encryption starts making sense when you 
* encrypt very long strings, of for example 10 000 characters or more.
* This is where asynchronous symmetrical encryption starts actually 
* improving performance or prevent browsers from just breaking.
* ---------------------------------------------------------------------
* Split a string into chunks of up to 3000 characters and encrypt them
* one at a time. Stringify the resulting array.
* ---------------------------------------------------------------------
* @param   {String}   data   
* @param   {String}   pass
* @param   {String}   algorithm   Algorithm to use for encryption.
*                                 "aes", "rijndael", "twofish", "serpent",
*                                 "aes-twofish" are possible.
*                                 
* @carries {Object}   carrier
* @calls   {Function}             function(String enc, Object carrier)
* */
			</pre>
			<h3 class="main">cipherJS.sym.decryptAsync</h3>
			<strong class="main"><code class="main">cipherJS.sym.decryptAsync(data, pass, callback, carrier)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Decrypt a string that was encrypted using cipherJS.sym.encryptAsync.
* Recognizes algorithm automatically.
* ---------------------------------------------------------------------
* Convert @data to an array of strings up to 3000 characters long and
* decrypt each of them. Join the resulting array to form the actual 
* cleartext.
* ---------------------------------------------------------------------
* @param   {String}   data      Encrypted data to decrypt
* @param   {String}   pass      Password to use for decryption
* @carries {Object}   carrier  
* @calls   {Function}           function(String dec, Object carrier)
* */
			</pre>
			<h3 class="main">Settings</h3>
			<p class="main">
				By default, all algorithms work with 256 bit keys, and use
				PBKDF2 (1000 iterations) for creating encryption keys from
				passwords.
			</p>
			<p class="main">
				AES operates in OCB2 mode by default, which is known as maybe the 
				best mode - performant and secure. <br>
				The other algorithms work in the somewhat not so perfect CBC mode 
				at the moment, sorry about that. CBC is not "bad", but doesn't
				support <a href="https://en.wikipedia.org/wiki/Authenticated_encryption"
				target="_blank">authenticated encryption</a>. cipherJS uses HMAC
				(encrypt then MAC) in combination with CBC mode to make up for this rather 
				vulnerable mode, so you should still be able to use Rijndael, Serpent and Twofish
				in <code class="main">cipherJS.sym</code> safely.
			</p>
			<p class="main">
				You might change the settings listed below, but please be aware of
				the fact the defaults are pretty sensible and well-tested. 
				Do not change them if not absolutely necessary.
			</p>
			<h4 class="main">String cipherJS.sym.aesMode</h4>
			<pre class="main">
/**
* "ocb2", "ccm", "cbc" and "gcm" are available. CCM is most widely used, but
* OCB is often referred to as the best mode. It can now be used in 
* non-military software freely and definetely used freely in open source
* software. DEFAULT: "ocb2".
* */
			</pre>
			<h4 class="main">Integer cipherJS.sym.aesIter</h4>
			<pre class="main">
/**
* Keys are derived from passwords and improved using PBKDF2. SJCL uses
* a cached PBKDF2, which is so fast you barely notice 1000 iterations
* and can probably go to 2000 without a problem. 1000 is really fast
* and the recommended minimum. DEFAULT: 1000.
* */
			</pre>
			<h4 class="main">Integer cipherJS.sym.aesKeysize</h4>
			<pre class="main">
/**
* 128, 192 and 256 are possible. 256 is extremely performant, so just
* always use this. Default: 256.
* */
			</pre>
			<h4 class="main">Integer cipherJS.sym.aesAuthStrength</h4>
			<pre class="main">
/**
* Strength of authentication tags which make sure encrypted messages
* aren't changed. 64, 96 and 128 are possible. Default: 128.
* */
			</pre>
			<h4 class="main">Integer cipherJS.sym.rijndaelKeysize</h4>
			<pre class="main">
/**
* Keysize for Rijndael encryption. 256 is default and recommended.
* */
			</pre>
			<h4 class="main">Integer cipherJS.sym.rijndaelIter</h4>
			<pre class="main">
/**
* Keys are derived from passwords and improved using PBKDF2. SJCL uses
* a cached PBKDF2, which is so fast you barely notice 1000 iterations
* and can probably go to 2000 without a problem. 1000 is really fast
* and the recommended minimum. DEFAULT: 1000.
* */
			</pre>
			<h4 class="main">Integer cipherJS.sym.twofishKeysize</h4>
			<pre class="main">
/**
* Keysize for Twofish encryption. 256 is default and recommended.
* */
			</pre>
			<h4 class="main">Integer cipherJS.sym.twofishIter</h4>
			<pre class="main">
/**
* Keys are derived from passwords and improved using PBKDF2. SJCL uses
* a cached PBKDF2, which is so fast you barely notice 1000 iterations
* and can probably go to 2000 without a problem. 1000 is really fast
* and the recommended minimum. DEFAULT: 1000.
* */
			</pre>
			<h4 class="main">Integer cipherJS.sym.serpentKeysize</h4>
			<pre class="main">
/**
* Keysize for Serpent encryption. 256 is default and recommended.
* */
			</pre>
			<h4 class="main">Integer cipherJS.sym.serpentIter</h4>
			<pre class="main">
/**
* Keys are derived from passwords and improved using PBKDF2. SJCL uses
* a cached PBKDF2, which is so fast you barely notice 1000 iterations
* and can probably go to 2000 without a problem. 1000 is really fast
* and the recommended minimum. DEFAULT: 1000.
* */
			</pre>
		</div>
		<div class="main" id="asymsimple">
			<h2 class="main">cipherJS.asym.simple</h2>
			<p class="main">
				cipherJS provides asymmetric (public key) cryptography
				in a way similar to what you may know from PGP or SSL/TLS with
				<code class="main">cipherJS.asym.simple</code>. Working
				with XML-based message- and keyblocks, <code class="main">cipherJS.asym.simple</code>
				uses the lower level functions in <code class="main">cipherJS.asym</code>.
			</p>
			<p class="main">
				If you haven't known and used public key cryptography before,
				research it, for example on <a href="https://en.wikipedia.org/wiki/Asymmetric_encryption" target="_blank">
				Wikipedia</a>, and read more about public key cryptography systems like PGP and SSL. <br>
				This documentation cannot explain public key cryptography, but there's 
				enough material available.
			</p>
			<p class="main">
				cipherJS public key cryptography works based on the performant ECC algorithm, 
				which provides pretty high security working with comparably small keys:
				An (NIST) ECC keypair with a public key size of 521 bit can provide the same
				level of security in encryption or signing an RSA keypair with a public key size 
				of 15360 (!) bit can provide.<br>
				ECC, however, is only used to create encryption keys. It needs an additional 
				symmetric algorithm. This by default is a combination of AES and Twofish, 
				but AES, Twofish,
				Rijndael and Serpent are available (AES is based on Rijndael but with minor
				changes, so both are included here).
			</p>
			<p class="main">
				In <code class="main">cipherJS.asym.simple</code>, you'll receive not private 
				and public key, but a "full keyset" and a "public keyset". <br>
				Treat the "full keyset" like you would treat a private key, and the "public keyset"
				like you would treat a public key.<br>
				The idea to have keysets comes from the situation that it is best to have two
				keypairs for each user - one for encryption, one for signing - in ECC, and that
			    some cipherJS functions which would normally only need a users secret key use the
			    public key as well (to verify the function output is valid and not broken due to
			    some browser issue etc.). <br> So the full keyset packs all 4 keys a user has (public 
			    encryption key, private encryption key, public signing key, private signing key) and
			    the public keyset only packs the two public keys.
			</p>
			<p class="main">
				If you want to learn more about the technical details behind the public key
				cryptography in cipherJS, read the documentation for <code class="main">cipherJS.asym</code>. 
				Refer to the
				source for more detail.
			</p>
			<p class="main" style="padding: 2%; border: 1px dashed black;">
				Please note that cipherJS' asymmetric functions for encryption and signing expect
				<strong class="main">masked</strong> input. Mask before encryption, unmask after 
				decryption. You can use <code class="main">cipherJS.mask</code> or write your own
				masker, but don't pass XML, JSON or whatever contains similar tags and characters.
			</p>
			<h3 class="main">cipherJS.asym.simple.generateKeyset</h3>
			<strong class="main"><code class="main">cipherJS.asym.simple.generateKeyset(bits, pass, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Generate a keyset for a user, possible bitlength are 256 and 521 
* (521 is recommended).
* ---------------------------------------------------------------------
* Two ECC keypairs (elGamal and ECDSA) are generated, both are of the
* bitlength specified with @bits. All keys are serialized, and the
* secret keys are symmetrically encrypted using @pass. The elGamal 
* keypair can later be used for encryption and decryption, the ECDSA
* keypair will be used for signing and verification. From these keys,
* an XML-string for a full keyset (could be stored on a server if you
* know what you do, as secret keys are only known to whoever knows 
* @pass) and for a public keyset (should be public for everyone who wants
* to send the owner a message, or wants to verify a signed message from
* the owner) are generated. 
* ---------------------------------------------------------------------
* @param   {Integer}   bits       Bitlength of the keys. 256 and 521
*                                 bit are possible here.
*                                 A small comparison of key strength:
*                                 ECC     |   RSA     |   AES
*                                 192     |   1024    |    -
*                                 224     |   2048    |    -
*                                 256     |   3072    |   128
*                                 384     |   7680    |   192
*                                 521     |   15360   |   256
*                                 Choose 256 if your data is "secret" only,
*                                 but better default to 521 bit ("top secret")
*                                 which is performant enough yet most
*                                 secure.
*                                 More information: http://www.keylength.com/
* 
* @param   {String}    pass       Password to symmetrically encrypt secret
*                                 key strings with.
* 
* @carries {Object}    carry  
* 
* @calls   {Function}  callback   function(Object keys, Object carrier)
*                                          keys:  String keyset
*                                                 String publickeyset
* */
			</pre>
			<h3 class="main">cipherJS.asym.simple.printId</h3>
			<strong class="main"><code class="main">cipherJS.asym.simple.printId(keyset)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* This function takes a keyset (full or public only) and generates its
* ID. 
* ---------------------------------------------------------------------
* A keysets' ID, the SHA256-hash of the signing and encryption public 
* key, can be used to check in a more human readable form if a keyset
* has changed. If the ID stays the same, the keys are the same (very,
* very, very likely - at least).
* ---------------------------------------------------------------------
* @param   {String}   keyset   XML string, representing a keyset (full
*                              or public only)
* @return  {String}   id       Hex string, representing the ID of the
*                              keyset.
* */
			</pre>
			<h3 class="main">cipherJS.asym.simple.encryptMessage</h3>
			<strong class="main"><code class="main">cipherJS.asym.simple.encryptMessage(receiverkeysets, cleartext, callback, carry, symkey)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
 * Encrypt a message with the receivers public keysets.
 * ---------------------------------------------------------------------
 * @param   {Array&lt;String&gt;}   receiverkeysets   The receivers' public keysets
 * @param   {String}          cleartext         Cleartext to encrypt
 * @param   {String}          symkey            Optional symmetric key, so the
 *                                              receivers can still decrypt
 *                                              using their private key, but 
 *                                              whoever already knows the @symkey
 *                                              can decrypt calling
 *                                              cipherJS.asym.symDecryptAsync(msg.between("&lt;ct&gt;", "&lt;/ct&gt;"), symkey, callback, carrier)
 *                                              Just don't provide it if all
 *                                              receivers will decrypt with their
 *                                              private keys, it is not necessary then.
 * @carries {Object}          carry
 * @calls   {Function}        callback          function(String msg, Object carrier)
 *                                                 msg is the encrypted message (XML string)
 * */
			</pre>
			<h3 class="main">cipherJS.asym.simple.decryptMessage</h3>
			<strong class="main"><code class="main">cipherJS.asym.simple.decryptMessage(message, receiverkeyset, pass, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
 * Decrypt a message using the receiver's full keyset.
 * ---------------------------------------------------------------------
 * @param   {String}   message          Message to decrypt (XML string, type encrypted)
 * @param   {String}   receiverkeyset   Receiver's full keyset
 * @param   {String}   pass             Password for @receiverkeyset
 * @carries {Object}   carry
 * @calls   {Function} callback         function(String cleartext, Object carry)
 * */
			</pre>
			<h3 class="main">cipherJS.asym.simple.signMessage</h3>
			<strong class="main"><code class="main">cipherJS.asym.simple.signMessage(cleartext, senderkeyset, pass, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Sign a message (cleartext) using the sender's keyset. 
* ---------------------------------------------------------------------
* @param   {String}   cleartext       Cleartext to sign
* @param   {String}   senderskeyset   Sender's full keyset
* @param   {String}   pass            Pass for @senderskeyset
* @carries {Object}   carry
* @calls   {Function} callback        function(String message, Object carry)
*                                        message is an XML string, representing a signed message
* */
			</pre>
			<h3 class="main">cipherJS.asym.simple.verifyMessage</h3>
			<strong class="main"><code class="main">cipherJS.asym.simple.verifyMessage(message, senderkeyset, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Verify a signed (not signed and encrypted) message using the senders'
* public keyset.
* ---------------------------------------------------------------------
* @param   {String}   message         Message to verify (XML string)
* @param   {String}   senderskeyset   Sender's public keyset
* @carries {Object}   carry
* @calls   {Function} callback        function(String ver, Object carry)
*                                        ver is "verified" || "unverified" 
* */
			</pre>
			<h3 class="main">cipherJS.asym.simple.encryptAndSignMessage</h3>
			<strong class="main"><code class="main">cipherJS.asym.simple.encryptAndSignMessage(receiverkeysets, senderkeyset, pass, cleartext, callback, carry, symkey)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Encrypt a message using the receivers' public keysets, and
* sign using the sender's full keyset.
* ---------------------------------------------------------------------
* @param   {Array&lt;String&gt;}   receiverkeysets   Receivers' public keysets
* @param   {String}          senderkeyset      Sender's full keyset
* @param   {String}          pass              Pass for @senderkeyset
* @param   {String}          cleartext         Cleartext to sign and encrypt
* @param   {String}          symkey            Optional symmetric key, so the
*                                              receivers can still decrypt
*                                              using their private key, but 
*                                              whoever already knows the @symkey
*                                              can decrypt calling
*                                              cipherJS.asym.symDecryptAsync(msg.between("&lt;ct&gt;", "&lt;/ct&gt;"), symkey, callback, carrier)
*                                              Just don't provide it if all
*                                              receivers will decrypt with their
*                                              private keys.
* @calls  {Function}         callback          function(String msg, Object carry)
*                                                 msg is the XML string representation of 
*                                                 the encrypted and signed message
* */
			</pre>
			<h3 class="main">cipherJS.asym.simple.decryptAndVerifyMessage</h3>
			<strong class="main"><code class="main">cipherJS.asym.simple.decryptAndVerifyMessage(message, receiverkeyset, pass, senderkeyset, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Decrypt a message using the receiver's full keyset and verify using
* the sender's public keyset.
* ---------------------------------------------------------------------
* @param   {String}   message           Message to decrypt (XML string)
* @param   {String}   receiverkeyset    Receiver's full keyset
* @param   {String}   pass              Pass for @receiverkeyset
* @param   {String}   senderkeyset      Sender's public keyset
* @carries {Object}   carry
* @calls   {Function} callback          function(Object dec, Object carry)
*                                          dec: String verified ("verified" || "unverified")
*                                               String cleartext
* */
			</pre>
			<h3 class="main">Settings</h3>
			<p class="main">
				Concerning settings, you might want to set 
				<code class="main">cipherJS.asym.symmetricAlgorithm</code> (a string
				value).<br>
				"aes", "rijndael", "twofish", "serpent", "aes-twofish" are currently
				supported.<br>
				The default is "aes-twofish" and usually, there's no reason to change this.
				When decrypting or verifying messages that were encrypted using a different
				symmetric algorithm than you set, there should be no problem as well, as
				the encryption algorithm is recognized automatically.<br>
				Only change the default if there is a sensible reason to do so.
			</p>
			<p class="main">
				<code class="main">cipherJS.asym</code> uses the functions 
				from <code class="main">cipherJS.sym</code>,
				so settings defined in <code class="main">cipherJS.sym</code> are used - keysizes,
				PBKDF2 iterations or block modes are defined there. If you change settings in
				<code class="main">cipherJS.sym</code>, it affects <code class="main">cipherJS.asym</code>.
			</p>
		</div>
		<div class="main" id="asym">
			<h2 class="main">cipherJS.asym</h2>
			<p class="main">
				<code class="main">cipherJS.asym</code> provides asymmetric
				encryption in cipherJS. You might want to use <code class="main">cipherJS.asym.simple</code> 
				in most cases. Use <code class="main">cipherJS.asym</code> only
				if you want to define your own system of message blocks and key blocks
				or none at all.
			</p>
			<p class="main">
				"<strong class="main">Symmetric encryption</strong>" in 
				<code class="main">cipherJS.asym</code> always refers to 
				using <code class="main">cipherJS.sym</code> with the algorithm
				defined in <code class="main">cipherJS.asym.symmetricAlgorithm</code>,
				default is "aes-twofish". <br>
				Messages are encrypted and decrypted asynchronously, while all other 
				ciphertexts (secret keys, symmetric keys...) are encrypted 
				synchronously.
			</p>
			<h3 class="main">cipherJS.asym.generateKeys</h3>
			<strong class="main"><code class="main">cipherJS.asym.generateKeys(bits, pass, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Generate a set of keys for encryption and signing. Choose a keysize
* of 521 or 256 bit if trying implement cross browsers compatibility,
* only these keys behave stable in most browsers.
* ---------------------------------------------------------------------
* ECC works somewhat different compared to RSA. It is best, most secure,
* not to have one keypair (2 keys) but two keypairs (4 keys) for a user.
* One keypair (cipherJS uses elGamal keys here) is used exclusively for
* encryption and decryption, the other keypair (ECDSA) is only used for
* signing and verification.
* cipherJS generates the two keypairs of a certain bitlength, and 
* encrypts each of the two secret keys symmetrically using @pass. All
* keys are serialized. This makes them pretty portable.
* All keystrings are UTF8-encoded, so choose yourself how you would
* encode them to store them or send them over the network. (Always be
* careful when storing anything but public keys on a server, and research
* possible security threats *carefully*).
* Key generation does happen asynchronously, so it should not hit
* browser limits.
* ---------------------------------------------------------------------
* @param   {Integer}   bits       Bitlength of the keys. 192, 224, 256, 
*                                 384 and 521 are possible. Only 256
*                                 and 521 are stable in less stable
*                                 webkit browsers such as several mobile
*                                 browsers or lightweight desktop 
*                                 browsers. So if you target all devices,
*                                 choose 256 and/ or 521 bit. If you only
*                                 target Firefox and Chrome, 192, 224 
*                                 and 384 are fine as well. However,
*                                 please consider 192 and 224 are somewhat
*                                 too weak for real world usage (just
*                                 an opinion). 
*                                 A small comparison of key strength:
*                                 ECC     |   RSA     |   AES
*                                 192     |   1024    |    -
*                                 224     |   2048    |    -
*                                 256     |   3072    |   128
*                                 384     |   7680    |   192
*                                 521     |   15360   |   256
*                                 In fact, you're at "top secret" level
*                                 with 384 and 521 bit, while a 256 bit
*                                 keyset is considered appropriate for
*                                 "secret" (not "top secret") data. 
*                                 521 bit is recommended as it is really,
*                                 really performant still, and most secure.
*                                 More information: http://www.keylength.com/
* 
* @param   {String}    pass       Password to symmetrically encrypt secret
*                                 key strings with.
* 
* @carries {Object}    carry  
* 
* @calls   {Function}  callback   function(Object keys, Object carrier)
*                                          keys:   Object encryption 
*                                                     encryption:   String pub
*                                                                   String sec
*                                                  Object signing
*                                                     signing:   String pub
*                                                                String sec
*                                                keys is null on error (i.e. if
*                                                generated keys are not valid, but
*                                                no exception occured). 
* */
			</pre>
			<h3 class="main">cipherJS.asym.encryptString</h3>
			<strong class="main"><code class="main">cipherJS.asym.encryptString(pubkeys, cleartext, callback, carry, symkey)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Encrypt a cleartext with the receivers' public keys.
* ---------------------------------------------------------------------
* A random key is generated, and the cleartext is symmetrically 
* encrypted using this random key. (If @symkey is provided, @symkey is
* used instead of a random key. The resulting @ciphertext can be 
* asymmetrically decrypted by receivers not knowing @symkey using their
* secret key, but who ever already knows @symkey can decrypt the
* ciphertext calling 
* cipherJS.asym.symDecryptAsync(ciphertext, symkey, callback, carrier) 
* which is much faster than decrypting using a private key.)
* 
* For each receiver, a random symmetric key is derived using their public
* key. With a public keytag (which can be sent over the network to the
* receiver), the receiver can find out this symmetric key using their
* secret key. No one else but the owner of the secret key is able to
* recover this symmetric key. With the symmetric key, @randkey is 
* symmetrically encrypted. The receiver of the message can now recover
* this symmetric key using their secret key, and that way decrypt 
* @randkey, which they then can use to decrypt the actual ciphertext.
* 
* As several encrypted keys are returned, a hash of the public key
* (yes, it could be all the public key, but this is just longer than a
* hash) is provided with each of them. So a receiver can hash their
* public key and check which of the cipherkeys is "theirs", by checking
* which of the hashes is identical to their hash. This avoids trial and
* error, instead lets a receiver see at once which key they can decrypt.
* 
* For all encryption but message encryption with @randkey (or @symkey), 
* cipherJS.asym.symEncrypt is used. cipherJS.asym.symEncryptAsync is 
* used for message encryption, as messages can be extremely long and 
* are better encrypted asynchronously.
* cipherJS.sym.hashPublicKey is used to create public key hashes. 
* ---------------------------------------------------------------------
* @param   {Array&lt;String&gt;}   pubkeys     Array of receivers' public keys
*                                        (encryption keys, elGamal)
* @param   {String}          cleartext   Cleartext to encrypt
* @param   {String}          symkey      Optional symmetric key, so the
*                                        receivers can still decrypt
*                                        using their private key, but 
*                                        whoever already knows the @symkey
*                                        can decrypt directly.
* @carries {Object}          carry
* @calls   {Function}                    function(Object enc, Object carrier)
*                                           enc: String ciphertext
*                                                Array enckeys
*                                                   Attributes of each enckey:
*                                                      String keyhash
*                                                      String cipherkey
*                                                      String keytag
* */
			</pre>
			<h3 class="main">cipherJS.asym.decryptString</h3>
			<strong class="main"><code class="main">cipherJS.asym.decryptString(ciphertext, seckey, pass, cipherkey, keytag, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Decrypt a given ciphertext using the receiver's private key.
* ---------------------------------------------------------------------
* @seckey is symmetrically decrypted using @pass. @cipherkey is 
* asymmetrically decrypted using @keytag and the decrypted @seckey (for
* symmetrical decryption). 
* Using the decrypted symmetric @cipherkey, @ciphertext is symmetrically
* decrypted, resulting in the actual cleartext.
* ---------------------------------------------------------------------
* @param   {String}   ciphertext     Encrypted text to decrypt 
* @param   {String}   cipherkey      Cipherkey which can be decrypted 
*                                    using @privkey
* @param   {String}   keytag         Keytag needed for decryption of
*                                    @cipherkey
* @param   {String}   seckey         Receivers' secret key 
*                                    (encryption key, elGamal)
* @param   {String}   pass           Password for @seckey
* @carries {Object}   carry  
* @calls   {Function} callback       function(Object dec, Object carrier)
*                                       dec:  String cleartext
* */
			</pre>
			<h3 class="main">cipherJS.asym.signString</h3>
			<strong class="main"><code class="main">cipherJS.asym.signString(cleartext, seckey, pass, pubkey, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Sign a cleartext using the sender's secret key.
* ---------------------------------------------------------------------
* A hash of the @cleartext is signed using the @seckey (after 
* decrypting with @pass) via ECDSA: A signature is derived from the
* secret key and the hash.
* The signature can be verified with the sender's public key by a 
* receiver if the cleartext is known to them as well. The signature
* is unique to the @seckey and the @cleartext. So if verified with the
* senders public key, it clearly was created using the sender's secret
* key.
* ---------------------------------------------------------------------
* @param   {String}   cleartext      Cleartext to sign
* @param   {String}   seckey         Senders' secret key (signing key, ECDSA)
* @param   {String}   pass           Pass for @seckey
* @param   {String}   pubkey         Sender's (!) public key (signing key, ECDSA)
*                                    which will be used to check if the signature
*                                    generated is valid.
* @carries {Object}   carry
* @calls   {Function} callback       function(Object signed, Object outercarrier)
*                                       signed: String signature (null if valid signature could not be generated)
*                                               String message (equals @cleartext)
* */
			</pre>
			<h3 class="main">cipherJS.asym.verifySignature</h3>
			<strong class="main"><code class="main">cipherJS.asym.verifySignature(cleartext, signature, pubkey, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Verify a cleartext's signature using the sender's public key.
* ---------------------------------------------------------------------
* Using ECDSA, the @signature of the @cleartext (the cleartext's hash,
* which is calculated from @cleartext) is verified with the sender's
* @pubkey. If it was really signed with the sender's private key, it
* will verify.
* ---------------------------------------------------------------------
* Browser related exceptions should be caught, though, have a retry
* option in your application if trying to target mobile and smaller
* browsers.
* ---------------------------------------------------------------------
* @param   {String}   cleartext      The cleartext 
* @param   {String}   signature      The signature to @cleartext
* @param   {String}   pubkey         The sender's public key
* @carries {Object}   outercarrier   
* @calls   {Function} callback       function(Object ver, Object carrier)
*                                       ver: String verified ("verified" | "unverified")
* */
			</pre>
			<h3 class="main">cipherJS.asym.encryptAndSignString</h3>
			<strong class="main"><code class="main">cipherJS.asym.encryptAndSignString(cleartext, pubkeys, pubkey, seckey, pass, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Encrypt a cleartext with the receivers' public keys, sign with 
* sender's secret key.
* ---------------------------------------------------------------------
* Uses cipherJS.asym.encryptString and cipherJS.asym.signString
* ---------------------------------------------------------------------
* @param   {String}          cleartext   Cleartext to encrypt
* @param   {Array&lt;String&gt;}   pubkeys     Array of receivers' public keys
*                                        (encryption keys, elGamal)
* @param   {String}          pubkey      Sender's public key used for signing
*                                        (ECDSA) (secret key is for signing,
*                                        public key for checking if signature
*                                        is valid)
* @param   {String}          seckey      Sender's secret key used for signing
*                                        (ECDSA)
* @param   {String}          pass        Pass for @seckey
* 
* @param   {String}          symkey      Optional symmetric key, so the
*                                        receivers can still decrypt
*                                        using their private key, but 
*                                        whoever already knows the @symkey
*                                        can decrypt directly.
* @carries {Object}          carry
* @calls   {Function}                    function(Object enc, Object carrier)
*                                           enc: String ciphertext
*                                                String signature
*                                                Array enckeys
*                                                   Attributes of each enckey:
*                                                      String keyhash
*                                                      String cipherkey
*                                                      String keytag
* */
			</pre>
			<h3 class="main">cipherJS.asym.decryptAndVerifyString</h3>
			<strong class="main"><code class="main">cipherJS.asym.decryptAndVerifyString(ciphertext, seckey, pass, cipherkey, keytag, signature, pubkey, callback, carry)</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* Decrypt and verify a string using the sender's public key and the
* receiver's secret key.
* ---------------------------------------------------------------------
* Decrypt a string using cipherJS.asym.decryptString, then verify
* signature using the decrypted cleartext and @pubkey using
* cipherJS.asym.verifySignature.
* ---------------------------------------------------------------------
* @param   {String}   ciphertext   Ciphertext to decrypt
* @param   {String}   seckey       Receiver's secret key (for decryption,
*                                  elGamal)
* @param   {String}   pass         Pass for @seckey
* @param   {String}   cipherkey    Cipherkey to be used for decryption
* @param   {String}   keytag       Keytag to be used for decryption
* @param   {String}   signature    Signature
* @param   {String}   pubkey       Sender's public key to verify signature
*                                  (ECDSA)
* @carries {Object}
* @calls   {Function} callback
* */
			</pre>
			<h3 class="main">cipherJS.asym.symmetricAlgorithm</h3>
			<strong class="main"><code class="main">String cipherJS.asym.symmetricAlgorithm</code></strong>
			<p class="main">
			</p>
			<pre class="main">
/**
* The symmetric algorithm setting defines the symmetric algorithm to be
* used by symEncrypt in this application. This is an application wide
* setting.
* "aes", "rijndael", "twofish", "serpent", "aes-twofish" are currently
* supported. They'll use the settings of cipherJS.sym, i.e. if you
* specify 256 bit keysize there it will be that, and if you specify
* only 128 bit keysize, that'll be that as well.
* cipherJS.asym.symDecrypt can decrypt data encrypted using
* cipherJS.asym.symEncrypt using another setting for @symmetricAlgorithm,
* as it recognized the algorithm automatically.
* DEFAULT: "aes-twofish".
* */
			</pre>
		</div>
		<h1 class="main" id="async">Asynchronous Javascript</h1>
		<div class="main" id="async_general">
			<p class="main">
				Javascript does not have a thing such as <code class="main">
				Thread.sleep</code> in other languages.<br>
				Still, Javascript functions cannot run endlessly, they hit browser
				limits pretty soon or freeze browsers.
			</p>
			<p class="main">
				To avoid hitting browser limits or freezing, functions can be
				called asynchronously using <code class="main">setTimeout</code>.
			</p>
			<p class="main">
				For example, if
				<code class="main"><br>
					function a(){<br>
						&nbsp;&nbsp;&nbsp; b(); //some other function<br>
						&nbsp;&nbsp;&nbsp; c(); //some other function<br>
						&nbsp;&nbsp;&nbsp; d(); //some other function<br>
						&nbsp;&nbsp;&nbsp; return e; //some return value<br>
					}<br><br>
				</code>
				is a long running function, the three functions in function a
				could be called asynchronously like that:
				<br>
				<code class="main"><br>
					a();<br>
					function a(){<br>
					    &nbsp;&nbsp;&nbsp; var callback = aCallbackFunction;<br>
						&nbsp;&nbsp;&nbsp; setTimeout(function(){b(callback);}, 10);<br>
					}<br>
					function b(callback){<br>
						&nbsp;&nbsp;&nbsp; // do some stuff<br>
						&nbsp;&nbsp;&nbsp; setTimeout(function(){c(callback);}, 10);<br>
					}<br>
					function c(callback){<br>
						&nbsp;&nbsp;&nbsp; // do some stuff<br>
						&nbsp;&nbsp;&nbsp; setTimeout(function(){d(callback);}, 10);<br>
					}
					function d(callback){<br>
						&nbsp;&nbsp;&nbsp; // do some stuff<br>
						&nbsp;&nbsp;&nbsp; var e = "whatever ;)"; <br>
						&nbsp;&nbsp;&nbsp; callback(e); //callback instead of return value<br> 
					}<br>
					function aCallbackFunction(e){<br>
						&nbsp;&nbsp;&nbsp; // do some stuff with e<br>
					}<br>
				</code>
			</p>
			<p class="main">
				Instead of returning a value, a callback function is called with the
				return value as a parameter. Of course, such a function must
				exist.
			</p>
			<p class="main">
				Passing callbacks as parameters allows calling an asynchronous
				function from different contexts.
			</p>
			<p class="main">
				Another problem is carrying variables. If you have a variable 
				<code class="main">var x = "abcdefg"</code> in function 
				<code class="main">a</code> before
				calling function <code class="main">b</code> asynchronously, 
				in the final callback function, there will be no <code class="main">x</code>
				like defined in <code class="main">a</code> in 
				<code class="main">callback</code>.
			</p>
			<p class="main">
				The problem of carrying variable values by passing them to each function
				called asynchronously and finally to the last callback can be solved by
				a carrier parameter that is passed on like the callback parameter.
			</p>
			<p class="main">
				A carrier parameter allows defining local variables in a function, storing
				them in an Object, passing that for the carrier param and then receiving it
				in the final callback then.
			</p>
			<p class="main">
				In the following example, two values will be passed:
			</p>
			<p class="main">
				<code class="main"><br>
					a();<br>
					function a(){<br>
					    &nbsp;&nbsp;&nbsp; var x = "abcdefg"; <br>
					    &nbsp;&nbsp;&nbsp; var y = "1234567"; <br>
					    &nbsp;&nbsp;&nbsp; var carrier = {"x": x, "y": y};
					    &nbsp;&nbsp;&nbsp; var callback = aCallbackFunction;<br>
						&nbsp;&nbsp;&nbsp; setTimeout(function(){b(callback, carrier);}, 10);<br>
					}<br>
					function b(callback, carrier){<br>
						&nbsp;&nbsp;&nbsp; // do some stuff<br>
						&nbsp;&nbsp;&nbsp; setTimeout(function(){c(callback, carrier);}, 10);<br>
					}<br>
					function c(callback, carrier){<br>
						&nbsp;&nbsp;&nbsp; // do some stuff<br>
						&nbsp;&nbsp;&nbsp; setTimeout(function(){d(callback, carrier);}, 10);<br>
					}
					function d(callback, carrier){<br>
						&nbsp;&nbsp;&nbsp; // do some stuff<br>
						&nbsp;&nbsp;&nbsp; var e = "whatever ;)"; <br>
						&nbsp;&nbsp;&nbsp; callback(e, carrier); //callback instead of return value<br> 
					}<br>
					function aCallbackFunction(e, carrier){<br>
						&nbsp;&nbsp;&nbsp; // do some stuff with e<br>
						&nbsp;&nbsp;&nbsp; // do some stuff with carrier <br>
					}<br>
				</code>
			</p>
			<p class="main">
				Passing callbacks and carriers allows a very flexible way of calling 
				Javascript functions asynchronously. 
			</p>
		</div>
		<div class="main" id="async_cipherjs">
			<h2 class="main">Asynchronous Javascript in cipherJS</h2>
			<p class="main">
				Asynchronous Javascript in cipherJS uses the approach of callbacks and
				carriers like described above. 
			</p>
			<p class="main">
				In the API docs, you'll find @return values for synchronous functions,
				and @carries as well as @calls (with a description what parameters the 
				callback function needs) for asynchronous functions.
			</p>
			<p class="main">
				An example with <code class="main">cipherJS.asym.simple.generateKeyset</code>:
			</p>
<pre class="main">
function take_keys(keys, carrier){
	// when cipherJS.asym.simple.generateKeyset is done,
	// this function will be called.
	// carrier in this case will be "testcarrier"
	// keys will be the keysets object.
}
cipherJS.asym.simple.generateKeyset(521, "testpassword", take_keys, "testcarrier");
</pre>
		</div>
		<h1 class="main" id="dangers">Dangers of (Javascript) cryptography</h1>
		<div class="main">
			<p class="main">
				Javascript cryptography allows HTML5 apps to be cryptographic
				applications. This of course has many advantages: HTML5 apps 
				run on nearly any device (desktop, tablet, mobile...), are easy
				to create and look better than native applications (most times).
			</p>
			<p class="main">
				Still, recently several Javascript crypto apps had security holes
				and severe bugs. Some of these flaws were bad enough no cryptography
				at all would've been better than the kind of "fake security" these
				applications brought.
			</p>
			<p class="main">
				While bugs are never completely avoidable,
				some of the "typical javascript crypto app problems" could've be avoided
				easily.
			</p>
			<p class="main">
				There are two factors that may contribute to such problems, or to
				their avoidance:<br>
				a) Javascript cryptography is not cryptography in a native application.
				Scripts in webapps are sent over the network, allowing an attacker to
				interfere. (This of course does not apply for add-ons or HTML5 based
				installed mobile apps.)<br>
				b) Cryptography is not the next best hip HTML5 feature, but something
				that requires a lot of care and never will provide 100% security. 
				The first thing attackers search for is some kind of security hole - a
				chance to inject a malicious script, giving a faked key to a user. Search for holes
				before they do.
			</p>
			<p class="main">
				Please read <a href="http://www.matasano.com/articles/javascript-cryptography/"
				target="_blank">Javascript Cryptography Considered Harmful</a>. cipherJS
				of course does not agree that one should just avoid Javascript cryptography, 
				but that you should know the dangers described there before working
				with cryptography in Javascript. 
			</p>
		</div>
		<div class="main" id="transmit">
			<h2 class="main">Transmit scripts securely</h2>
			<p class="main">
				It is surprisingly easy for an attacker to interfere with HTTP traffic. They
				may just inject a malicious script, and catch all the data before it is 
				encrypted.
			</p>
			<p class="main">
				There are two possible solutions. One is not to develop a web application, but
				an add-on and maybe a HTML5 mobile app for common smartphone OS'. The other
				solution is to work with decent HTTPS.
			</p>
			<p class="main">
				The add-on and possible app solution is the cheapest and most secure. It 
				is not much different from developing and distributing a desktop application.
			</p>
			<p class="main">
				The HTTPS solution is more expensive and - as you need to configure everything
				correctly - maybe a bit more difficult, depending on whether you try to do
				everything yourself or find some reliable hosting.<br>
				Take care no external scripts served over HTTP are included. Take care as well
				you trust the hoster of external scripts, or host all the scripts yourself
				(yes, jQuery or a lightweight replacement you might find is meant as well).
			</p>
		</div>
		<div class="main" id="keystorage">
			<h2 class="main">Storing keys on a server</h2>
			<p class="main">
				In cipherJS keysets, all secret keys are symmetrically encrypted with the users
				password. Default is a combination of AES and Twofish, with 256 bit keys and
				1000 PBKDF2 iterations. <br>
				This sounds like a sensible default, and no one should most likely
				be able to crack the encryption
				of the keys.
			</p>
			<p class="main">
				Still, it is not necessarily a good idea to store keys on a server.<br>
				If a user looses their password, there's only one solution: Securily wiping
				the keyset from their disk so no one else may decrypt the messages with the
				password and keyset. If the keyset is on a server, and an attacker gets the
				password, the attacker may read all the messages. If the user stores their
				keyset on their local disk only, they might delete it before the attacker
				gets it.
			</p>
			<p class="main">
				An option is only storing public keys online and full keysets locally, 
				for example
				one per device in HTML5 storage. This would result in a user having multiple
				keysets.
			</p>
			<p class="main">
				Still, it could be better allowing users to export their keys as a file and 
				use them with their same account on another device. They would never be on the
				server, but users would just "export" them from their 
				own disk and "import" them
				to their HTML5 storage or a folder on another device.<br>
				With a usable graphic interface (do not expect "normal" users to fiddle with
				config files), this may be the best solution.<br>
				If you use HTML5 storage, try and use the HTML5 file API to create a keyset
				backup as a local file. HTML5 storage is limited and easily deleted.
			</p>
			<p class="main">
				If you absolutely need to store keysets on a server, give users the option to
				use keyfiles in addition to passwords.
			</p>
			<p class="main">
				You may give users up to 4 options: Store their keysets on your server and just
				use a password, store on a server with password and local keyfile, store keys 
				locally with a password, or store keys locally with password and (local) keyfile.
			</p>
		</div>
		<div class="main" id="transparency">
			<h2 class="main">Trust in your application</h2>
			<p class="main">
				As always, users have to trust your application it does what you claim it does.
				In fact, no matter what way you choose to proof your application secure,
				it could almost always still be a lie. So aim for as much proof as possible.
			</p>
			<p class="main">
				Generally, there are two ways of proving an application does what it says. The
				first one is publishing it as an open source project, best on a large open source
				hosting such as Github or SourceForge. The second one is rather expensive and
				involves a security company to certify the security of your application - which
				would need another check for each update, no matter how little it is, that changes
				the binaries.<br>
				Publishing the code seems to be much easier and cheaper. Users could still pay 
				for using your servers (mailserver, chatserver...), so you could sell the service
				and keep the client application open, no need for security analysis.
			</p>
			<p class="main">
				In Javascript, especially in add-ons, you have one more great way to allow users
				to check you're not cheating.<br>
				When transferring scripts over the network, you may choose minified scripts to
				limit your and your users bandwidth usage.<br>
				But when distruting an add-on, focus on readable Javascript, use non-minified scripts.
				An add-on is only downloaded once for install, and then no more. Twice the filesize
				is worth readable Javascript - anyone could just unpack the add-on file and see
				what is bundled there.
			</p>
		</div>
		<div class="main" id="mim">
			<h2 class="main">The man in the middle attack</h2>
			<p class="main">
				All crypto applications using public key cryptography 
				have to deal with the problem of the "Man in the Middle"-Attack.
				<br>
				At the moment, there is no mathematical/ cryptographical/ technical solution
				to this problem - yes, none.
			</p>
			<p class="main">
				As the MiM attack is well described in thousands of articles on the
				internet, there's no need in redescribing it here. 
				<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank">Even the Wikipedia article</a>
				already gives pretty much all the information needed for working
				with cipherJS.
			</p>
			<p class="main">
				Today's only answer to the MiM attack is a PKI (Public Key Infrastructure).
				For cipherJS, this could mean a) spread public keysets as widely as possible
				and b) display contacts' public keyset IDs to users in your application.
			</p>
			<p class="main">
				For group conversation keys you might use in an application, 
				a short representation (colors, a short string ...) could
				be displayed to all users, so they can manually check whether the
				keys they see are the same (via phone for example, but 
				anything is better than no checking at all). 
				In case of a man in the middle attack, the identifiers for conversation
				keys would differ.<br>
				Read <a href="https://www.schneier.com/blog/archives/2008/07/maninthemiddle_1.html" target="_blank">
				this article (from Schneier on Security) 
				</a> for more ideas and approaches. 
			</p>
			<p class="main">
				But please don't rely on color combinations only. A lot of people, many more
				than you might think, are visually impaired. Some are blind, but some are 
				"just" colorblind - in fact, 10% of males and 1% of females are colorblind. It
				confuses and scares users if they and their colorblind contact see different
				colors thinking there's an attack.<br>
				Some string representation should always be available, as checking this is 
				less convenient but less prone to false alarms.
			</p>
			<p class="main">
				<br><br><br>
			</p>
		</div>
	</body>
</html>
